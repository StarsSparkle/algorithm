排序算法
===
### 术语说明<br>
 稳定 ：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；<br>
 不稳定 ：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；<br>
 原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。<br>
 非原地排序：需要利用额外的数组来辅助排序。<br>
 时间复杂度 ： 一个算法执行所耗费的时间。<br>
 空间复杂度 ：运行完一个程序所需内存的大小。<br>

**内排序**：指在排序期间数据对象全部存放在内存的排序。<br>
**外排序**：在内存中进行的排序称为内部排序，而在许多实际应用中，经常需要对大文件进行排序，因为文件中的记录很多，信息量庞大，无法将整个文件拷贝进内存进行排序。因此，需要将带排序的记录存储在外存上，排序时再把数据一部分一部分的调入内存进行排序，在排序中需要多次进行内外存的交互，对外存文件中的记录进行排序后的结果仍然被放到原有文件中。这种排序方法就称外部排序。<br>  
由于外存设备的不同，外部排序通常分为磁盘文件排序和磁带文件排序。磁盘是直接存取设备，磁带是顺序存取设备。<br>  
文件通常是按块存储在磁盘上，操作系统也是按块对磁盘上的信息进行读写的。因为磁盘读写的机械运动所需的时间远远超过内存计算的时间。因此，在外部排序过程中的时间代价主要考虑访问磁盘的次数，即i/o次数。<br>  
外部排序通常采用归并排序：它包括两个相对独立的阶段：<br>  首先，根据内存缓存区的大小，将外存上含有n个记录的文件分割成若干长度为 h 的子文件，依次的读入内存并利用有效的内部排序方法对他们进行排序，并将排序后得到的有序子文件重新写回外存，通常称这些有序子文件为归并段或者顺串。<br>  然后，对这些归并段进行逐趟归并，使得归并段（有序的子文件）逐渐由小到大，直至得到整个有序文件为止。之后还可以采用多路平衡归并和败者树，置换-选择排序，最佳归并树进行处理。<br>

**衡量效率的方法**<br>
内部排序：比较次数，也就是时间复杂度<br>
外部排序：IO次数，也就是读写外存的次数<br>

内排序
-----
**算法分类**<br>
**比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。<br>
**非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 <br>
>比较类排序
>>交换排序
>>>冒泡排序
>>>快速排序

>>插入排序
>>>简单插入排序
>>>希尔排序

>>选择排序
>>>简单选择排序
>>>堆排序

>>归并排序
>>>二路归并排序
>>>多路归并排序

>非比较类排序
>>基数排序
>>计数排序
>>桶排序

### 1 冒泡排序（Bubble Sort）
冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 <br>
**1.1 算法描述**<br>
比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>
针对所有的元素重复以上的步骤，除了最后一个；<br>
重复步骤1~3，直到排序完成。<br>
**1.2 代码**<br>
```python
def bubble(a):
    n = len(a)
    for i in range(n-1):
        count = 0
        for j in range(n-1-i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
                count += 1
        if count == 0:
            break
    return a
```
**1.3 复杂度，稳定性，应用**<br>
时间复杂度：平均O(n*n)，最好O(n)，最坏O(n*n)。<br>
空间复杂度：O(1)<br>
稳定性：稳定，原地排序<br>
应用：<br>


### 2 选择排序（Selection Sort)
选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 <br>
**2.1 算法描述**<br>
n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：
初始状态：无序区为R[1..n]，有序区为空；
第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
n-1趟结束，数组有序化了。
**2.2 代码**<br>
```python
def selection(a):
    n = len(a)
    for i in range(n-1):
        minindex = i
        for j in range(i+1, n):
            if a[minindex] > a[j]:
                minindex = j
        a[minindex],a[i] = a[i],a[minindex]
    return a
```
**2.3 复杂度，稳定性，应用**<br>
时间复杂度：平均O(n*n),最好O(n*n)，最坏O(n*n)。<br>
空间复杂度：O(1)<br>
稳定性：不稳定，原地排序<br>
应用：<br>


### 3 插入排序（Insertion Sort)
插入排序的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 <br>
**3.1 算法描述**<br>
一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<br>
从第一个元素开始，该元素可以认为已经被排序；<br>
取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>
如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>
重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
将新元素插入到该位置后；
重复步骤2~5。
**3.2 代码**<br>
```python
def insertion(a):
    n = len(a)
    for i in range(1,n):
        temp = a[i]
        j = i-1
        while j >= 0 and temp < a[j]:
            a[j+1] = a[j]
            a[j] = temp
            j -= 1
    return a
```
**3.3 复杂度，稳定性，应用**<br>
时间复杂度：平均O(n*n),最好O(n)，最坏O(n*n)。<br>
空间复杂度：O(1)<br>
稳定性：稳定，原地排序<br>
应用：<br>


### 4 希尔排序（Shell Sort）
1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 <br>
**4.1 算法描述**<br>
先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：<br>
选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
按增量序列个数k，对序列进行k 趟排序；
每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
**4.2 代码**<br>
```python
def shell(a):
    n = len(a)
    gap = n//2
    #对每组间隔为gap的分组进行排序，刚开始gap = n // 2;
    while(gap > 0):
        #对各个局部分组进行插入排序
        i = gap
        while(i<n):
            j = i - gap
            temp = a[i]
            while j >= 0 and temp < a[j]:
                a[j+gap] = a[j]
                a[j] = temp
                j = j-gap
            i += 1
        gap = gap//2
```
**4.3 复杂度，稳定性，应用**<br>
时间复杂度：O(nlgn) or O(n^1.3) <br>
空间复杂度：O(1)<br>
稳定性：非稳定排序 ，原地排序<br>
应用：<br>


### 5 快速排序
 <br>
**5.1 算法描述**<br>
<br>
**5.2 代码**<br>
```python

```
**5.3 复杂度，稳定性，应用**<br>
时间复杂度：平均O(),最好O()，最坏O()。<br>
空间复杂度：O()<br>
稳定性：<br>
应用：<br>


### 6 归并排序（Merge Sort）
归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 <br>
**6.1 算法描述**<br>
把长度为n的输入序列分成两个长度为n/2的子序列；<br>
对这两个子序列分别采用归并排序；<br>
将两个排序好的子序列合并成一个最终的排序序列。<br>
**6.2 代码**<br>
```python

```
**6.3 复杂度，稳定性，应用**<br>
时间复杂度：平均O(),最好O()，最坏O()。<br>
空间复杂度：O()<br>
稳定性：<br>
应用：<br>




### 7 堆排序
 <br>
**7.1 算法描述**<br>
<br>
**7.2 代码**<br>
```python

```
**7.3 复杂度，稳定性，应用**<br>
时间复杂度：平均O(),最好O()，最坏O()。<br>
空间复杂度：O()<br>
稳定性：<br>
应用：<br>



